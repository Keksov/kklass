#!/bin/bash
# kklass_compiler.sh - Compile class definitions to optimized bash code
# Usage: bash kklass_compiler.sh input.kk output.sh

source "$(dirname "${BASH_SOURCE[0]}")/kklass.sh"

compile_class_file() {
    local input_file="$1"
    local output_file="$2"
    
    [[ ! -f "$input_file" ]] && { echo "Error: Input file not found: $input_file" >&2; return 1; }
    
    # Source input file to create classes in current shell
    source "$input_file" >/dev/null 2>&1
    
    # Get all defined classes by finding .new functions
    local class_list=($(compgen -A function | grep '\.new$' | sed 's/\.new$//'))
    
    [[ ${#class_list[@]} -eq 0 ]] && { echo "Error: No classes found in $input_file" >&2; return 1; }
    
    # Create output file with header
    cat > "$output_file" <<'HEADER'
#!/bin/bash
# Auto-generated by kklass_compiler.sh
# DO NOT EDIT MANUALLY - Changes will be overwritten

HEADER
    
    echo "# Class metadata and constructors" >> "$output_file"
    
    # Export each class
    for class_name in "${class_list[@]}"; do
        {
            echo ""
            echo "# ===== Class: $class_name ====="
            
            # Export properties array
            local props_var="${class_name}_class_properties"
            if declare -p "$props_var" &>/dev/null; then
                declare -p "$props_var" | sed "s/declare -a /declare -ga /"
            fi
            
            # Export methods array
            local meths_var="${class_name}_class_methods"
            if declare -p "$meths_var" &>/dev/null; then
                declare -p "$meths_var" | sed "s/declare -a /declare -ga /"
            fi
            
            # Export parent class
            local parent_var="${class_name}_parent_class"
            local parent_val="${!parent_var}"
            printf "declare -g %s=%q\n" "$parent_var" "$parent_val"
            
            # Export method cache
            echo "declare -gA ${class_name}_method_cache"
            
            # Export method bodies
            local -n meths_ref="$meths_var" 2>/dev/null
            if [[ -n "${meths_ref[@]}" ]]; then
                for m in "${meths_ref[@]}"; do
                    local body_var="${class_name}_method_body_${m}"
                    printf "declare -g %s=%q\n" "$body_var" "${!body_var}"
                    
                    # Pre-populate cache
                    echo "${class_name}_method_cache[\"${m}\"]=\"${class_name}\""
                done
            fi
            
            # Get instance template for this specific class
            local template_var="${class_name}_instance_template"
            local template_val="${!template_var}"
            
            # Create optimized constructor with embedded template
            cat <<CONSTRUCTOR_EOF
${class_name}.new() {
    local instname="\$1"
    [[ "\$instname" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]] || { echo "Invalid instance name: \$instname" >&2; return 1; }
    local instance_template=$(printf '%q' "$template_val")
    source <(sed "s/__INST__/\$instname/g" <<< "\$instance_template")
}
CONSTRUCTOR_EOF
            echo ""
            
        } >> "$output_file"
    done
    
    # Add footer
    cat >> "$output_file" <<EOF

# Compiled classes: ${class_list[*]}
# Generated: $(date)
# Source: $input_file
EOF
    
    chmod +x "$output_file"
    
    echo "âœ“ Compiled ${#class_list[@]} classes to: $output_file"
    echo "  Classes: ${class_list[*]}"
    echo "  Usage: source $output_file && ClassName.new instance_name"
}

# Main
if [[ $# -lt 2 ]]; then
    cat <<'USAGE'
Usage: bash kklass_compiler.sh <input.kk> <output.sh>

Compiles class definitions from input file into optimized bash code.

Example:
    # Compile classes
    bash kklass_compiler.sh my_classes.kk my_classes_compiled.sh
    
    # Use compiled classes
    source my_classes_compiled.sh
    MyClass.new myobj
    myobj.method_name
USAGE
    exit 1
fi

compile_class_file "$1" "$2"
